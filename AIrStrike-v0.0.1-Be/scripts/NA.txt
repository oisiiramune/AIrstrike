import { world, system } from "@minecraft/server";

const TICK_INTERVAL = 1;
const ANGLE_STEP = 1.1;
const TERMINATION_ANGLE = 30;
const EXPLOSION_POWER = 7;
const STEP_DISTANCE = 4.25;
const MAX_DISTANCE = 105;
const Y_OFFSETS = [8, 16, 24, 32];

const nukeRotations = new WeakMap();
const executedPositions = new Set();
let explosionLocations = [];

system.runInterval(() => {
  const dimension = world.getDimension("overworld");

  for (const nuke of dimension.getEntities({ type: "ais:nuke" })) {
    let angle = nukeRotations.get(nuke) ?? 0;
    const center = nuke.location;

    for (let offset = 0; offset < 360; offset += 15) {
      const rad = ((angle + offset) * Math.PI) / 180;

      for (let d = STEP_DISTANCE; d <= MAX_DISTANCE; d += STEP_DISTANCE) {
        const x = center.x + Math.cos(rad) * d;
        const y = center.y;
        const z = center.z + Math.sin(rad) * d;
        const key = `${x.toFixed(2)}:${y.toFixed(2)}:${z.toFixed(2)}`;
        if (!executedPositions.has(key)) {
          executedPositions.add(key);
          explosionLocations.push({ x, y, z });
        }
      }

      for (const yOffset of Y_OFFSETS) {
        for (let d = STEP_DISTANCE; d <= MAX_DISTANCE; d += STEP_DISTANCE) {
          const x = center.x + Math.cos(rad) * d;
          const y = center.y + yOffset;
          const z = center.z + Math.sin(rad) * d;
          const key = `${x.toFixed(2)}:${y.toFixed(2)}:${z.toFixed(2)}`;
          if (!executedPositions.has(key)) {
            executedPositions.add(key);
            explosionLocations.push({ x, y, z });
          }
        }
      }

      const undergroundOffsets = [-4, -8, -12];
      const explosionRadii = {
        "-4": 80,
        "-8": 60,
        "-12": 30
      };

      for (const yOffset of undergroundOffsets) {
        const radius = explosionRadii[yOffset];
        const y = center.y + yOffset;
        if (y >= -60) {
          for (let d = STEP_DISTANCE; d <= radius; d += STEP_DISTANCE) {
            const x = center.x + Math.cos(rad) * d;
            const z = center.z + Math.sin(rad) * d;
            const key = `${x.toFixed(2)}:${y.toFixed(2)}:${z.toFixed(2)}`;
            if (!executedPositions.has(key)) {
              executedPositions.add(key);
              explosionLocations.push({ x, y, z });
            }
          }
        }
      }
    }

    angle += ANGLE_STEP;
    if (angle >= TERMINATION_ANGLE) {
      nukeRotations.delete(nuke);
      nuke.kill();
    } else {
      nukeRotations.set(nuke, angle);
    }
  }

  if (explosionLocations.length > 0) {
    const queued = [...explosionLocations];
    explosionLocations = [];

    system.run(() => {
      const dimension = world.getDimension("overworld");
      for (const loc of queued) {
        try {
          dimension.createExplosion(loc, EXPLOSION_POWER, {
            breaksBlocks: true,
            causesFire: false
          });
        } catch {}
      }
    });
  }
}, TICK_INTERVAL);